      SUBROUTINE FFTF1D(CARRAY,NX,IFORW)

C     *************************************************************************
C
C     FFTF1D
C     ======
C
C     AUTHOR
C     ------
C     R.S.CANT  --  CAMBRIDGE UNIVERSITY ENGINEERING DEPARTMENT
C
C     CHANGE RECORD
C     -------------
C     07-JUN-1995:  CREATED
C     06-DEC-1998:  RSC MODIFIED FOR IMPROVED PERFORMANCE
C
C     DESCRIPTION
C     -----------
C     CARRIES OUT AN FFT IN 1D
C     ADAPTED FROM THE "NUMERICAL RECIPES" SUBROUTINE FOURN
C
C     REFERENCES
C     ----------
C     1) NUMERICAL RECIPES 1st Ed, CUP (1986) pp451-453
C
C     *************************************************************************


C     PARAMETERS
C     ==========
      DOUBLE PRECISION ZERO,ONE,TWO,EIGHT
      PARAMETER(ZERO=0.0D0, ONE=1.0D0, TWO=2.0D0, EIGHT=8.0D0)
      INTEGER NBTMAX
      PARAMETER(NBTMAX=13)


C     ARGUMENTS
C     =========
      INTEGER NX,IFORW
      DOUBLE PRECISION CARRAY(2*NX)


C     LOCAL DATA
C     ==========
      DOUBLE PRECISION COSKTH,SINKTH,COSTHT,SINTHT,COSTMP,ARGMNT,TWOPI
      DOUBLE PRECISION DANLRE,DANLIM
      INTEGER IXBITS(NBTMAX),IXTWOS(NBTMAX)
      INTEGER JBITS,NBITS
      INTEGER IX,JX,KX,IXRE,IXIM,JXRE,JXIM,NSTAGE,ITSTEP,NXSIZE


C     BEGIN
C     =====

C     SET VALUE OF 2*PI
      TWOPI = EIGHT*ATAN(ONE)


C     BIT REVERSAL
C     ------------

C     INITIALISE BIT ARRAYS
      NBITS = NINT(LOG(REAL(NX))/LOG(TWO)) 
      DO JBITS = 1,NBITS
        IXBITS(JBITS) = 0
      ENDDO
      IXTWOS(1) = NX/2
      DO JBITS = 2,NBITS
        IXTWOS(JBITS) = IXTWOS(JBITS-1)/2 
      ENDDO

C     LOOP THROUGH TRANSFORM ELEMENTS
      DO IX = 2,NX-1

C       BUILD BIT SEQUENCE OF SOURCE INDEX
        JBITS = 1
1000    CONTINUE
          IXBITS(JBITS) = IXBITS(JBITS)+1
          IF(IXBITS(JBITS).GT.1)THEN
            IXBITS(JBITS) = 0
            JBITS = JBITS+1
            GOTO 1000
          ENDIF
C       END OF BIT SEQUENCE LOOP

C       BIT REVERSE TO GET DESTINATION INDEX
        JX = 1
        DO JBITS = 1,NBITS
          JX = JX + IXBITS(JBITS)*IXTWOS(JBITS)
        ENDDO

C       SWAP ONLY IF DESTINATION INDEX IS GREATER THAN SOURCE INDEX
        IF(JX.GT.IX)THEN

C         SWAP THE ELEMENTS
          IXIM = 2*IX
          IXRE = IXIM-1
          JXIM = 2*JX
          JXRE = JXIM-1
          DANLRE = CARRAY(IXRE)
          DANLIM = CARRAY(IXIM)
          CARRAY(IXRE) = CARRAY(JXRE)
          CARRAY(IXIM) = CARRAY(JXIM)
          CARRAY(JXRE) = DANLRE
          CARRAY(JXIM) = DANLIM

        ENDIF

      ENDDO


C     DANIELSON-LANCZOS FORMULA
C     -------------------------
      NXSIZE = NX*2
      NSTAGE = 2

C     LOOP OVER TRANSFORM SIZES (2 UP TO NX/2)
2000  CONTINUE
      IF(NSTAGE.LT.NXSIZE)THEN

        ITSTEP = 2*NSTAGE

C       INITIALISE COEFFICENT FUNCTION
        ARGMNT = REAL(IFORW)*TWOPI/REAL(NSTAGE)
        COSTHT = COS(ARGMNT)
        SINTHT = SIN(ARGMNT)
        COSKTH = ONE
        SINKTH = ZERO

C       LOOP OVER ELEMENTS OF EACH TRANSFORM
        DO KX = 1,NSTAGE,2

C         LOOP OVER TRANSFORMS OF SIZE NSTAGE
          DO IXRE = KX,NXSIZE,ITSTEP
            IXIM = IXRE+1
            JXRE = IXRE+NSTAGE
            JXIM = JXRE+1
            DANLRE = COSKTH*CARRAY(JXRE) - SINKTH*CARRAY(JXIM)
            DANLIM = COSKTH*CARRAY(JXIM) + SINKTH*CARRAY(JXRE)
            CARRAY(JXRE) = CARRAY(IXRE) - DANLRE
            CARRAY(JXIM) = CARRAY(IXIM) - DANLIM
            CARRAY(IXRE) = CARRAY(IXRE) + DANLRE
            CARRAY(IXIM) = CARRAY(IXIM) + DANLIM
          ENDDO

C         RECURRENCE FOR COEFFICIENT FUNCTION
          COSTMP = COSKTH*COSTHT - SINKTH*SINTHT
          SINKTH = SINKTH*COSTHT + COSKTH*SINTHT
          COSKTH = COSTMP

        ENDDO

C       NEXT SIZE UP
        NSTAGE = ITSTEP
        GO TO 2000

      ENDIF


      RETURN
      END
